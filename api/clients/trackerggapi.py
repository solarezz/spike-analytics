import httpx
import asyncio
from typing import Dict, List, Optional, Any
import json
import cloudscraper
import time
import random
import urllib.parse

class TrackerGGAPI:
    """–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Tracker.gg API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
    
    BASE_URL = "https://api.tracker.gg/api/v2/valorant/standard"
    
    def __init__(self):
        # –û–±—ã—á–Ω—ã–π httpx –∫–ª–∏–µ–Ω—Ç
        self.client = httpx.AsyncClient(
            headers={
                "User-Agent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Mobile Safari/537.36",
                "Accept": "application/json",
            },
            timeout=30.0
        )
        
        # CloudScraper –¥–ª—è –æ–±—Ö–æ–¥–∞ Cloudflare
        self.cloud_scraper = cloudscraper.create_scraper(
            browser={
                'browser': 'chrome',
                'platform': 'android',
                'mobile': True
            }
        )
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ CloudScraper
        self.cloud_scraper.headers.update({
            "Accept": "application/json, text/plain, */*",
            "Accept-Encoding": "gzip, deflate, br",
            "Accept-Language": "ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7",
            "Cache-Control": "no-cache",
            "DNT": "1",
            "Origin": "https://tracker.gg",
            "Pragma": "no-cache",
            "Sec-Fetch-Dest": "empty",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Site": "same-origin",
        })
    
    async def get_enhanced_player_stats(self, riot_id: str, tagline: str) -> Optional[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–≥—Ä–æ–∫–∞ –¥–ª—è –∫–∞—Ä—Ç–æ—á–∫–∏"""
        
        raw_data = await self.get_player_profile(riot_id, tagline)
        if not raw_data or 'data' not in raw_data:
            return None
            
        segments = raw_data['data'].get('segments', [])
        if not segments:
            return None
            
        # –ò—â–µ–º —Ç–µ–∫—É—â–∏–π —Å–µ–∑–æ–Ω–Ω—ã–π —Å–µ–≥–º–µ–Ω—Ç competitive
        current_season = None
        peak_rating = None
        all_agents = []  # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ—Ö –∞–≥–µ–Ω—Ç–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å–∞–º–æ–≥–æ –∏–≥—Ä–∞–µ–º–æ–≥–æ
        
        for segment in segments:
            seg_type = segment.get('type', '')
            attributes = segment.get('attributes', {})
            
            # –¢–µ–∫—É—â–∏–π —Å–µ–∑–æ–Ω competitive
            if seg_type == 'season' and attributes.get('playlist') == 'competitive':
                if current_season is None:  # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–π (–æ–±—ã—á–Ω–æ —Ç–µ–∫—É—â–∏–π)
                    current_season = segment
                    
            # –ü–∏–∫–æ–≤—ã–π —Ä–µ–π—Ç–∏–Ω–≥
            elif seg_type == 'peak-rating' and attributes.get('playlist') == 'competitive':
                peak_rating = segment
                
            # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ—Ö –∞–≥–µ–Ω—Ç–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å–∞–º–æ–≥–æ –∏–≥—Ä–∞–µ–º–æ–≥–æ
            elif seg_type == 'agent' and attributes.get('playlist') == 'competitive':
                all_agents.append(segment)
        
        if not current_season:
            print("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω current_season —Å–µ–≥–º–µ–Ω—Ç")
            print(f"üîç –î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã: {[s.get('type') for s in segments]}")
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            return {
                'riot_id': riot_id,
                'tagline': tagline,
                'region': 'N/A',
                'account_level': 'N/A',
                'current_rank': 'Unranked',
                'matches_played': 0,
                'matches_won': 0,
                'win_rate': 0,
                'kills': 0,
                'deaths': 0,
                'assists': 0,
                'kd_ratio': 0,
                'damage_per_round': 0,
                'headshot_pct': 0,
                'favorite_agent': 'Unknown'
            }
            
        # –ù–∞—Ö–æ–¥–∏–º –∞–≥–µ–Ω—Ç–∞ —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –º–∞—Ç—á–µ–π
        favorite_agent = None
        max_matches = 0
        
        for agent_segment in all_agents:
            agent_stats = agent_segment.get('stats', {})
            if 'matchesPlayed' in agent_stats:
                matches_played = agent_stats['matchesPlayed'].get('value', 0)
                if isinstance(matches_played, (int, float)) and matches_played > max_matches:
                    max_matches = matches_played
                    favorite_agent = agent_segment
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        stats = current_season.get('stats', {})
        
        def get_stat_value(stat_name: str, default=None):
            """–ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
            if stat_name in stats:
                stat_info = stats[stat_name]
                return stat_info.get('displayValue', stat_info.get('value', default))
            return default
            
        def get_rank_info(stat_name: str):
            """–ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ä–∞–Ω–≥–µ —Å metadata"""
            if stat_name in stats:
                rank_info = stats[stat_name]
                metadata = rank_info.get('metadata', {})
                tier_name = metadata.get('tierName')
                
                if tier_name:
                    return tier_name
                # Fallback –Ω–∞ displayValue –∏–ª–∏ value
                display_value = rank_info.get('displayValue')
                if display_value and display_value != "Unranked":
                    return display_value
                return rank_info.get('value')
            return None
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        result = {
            # –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            'riot_id': riot_id,
            'tagline': tagline,
            'region': raw_data['data'].get('metadata', {}).get('activeShard', 'N/A'),  # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–≥–∏–æ–Ω –∏–∑ metadata
            'account_level': raw_data['data'].get('metadata', {}).get('accountLevel', 'N/A'),  # –î–æ–±–∞–≤–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å –∏–∑ metadata
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –º–∞—Ç—á–µ–π
            'matches_played': get_stat_value('matchesPlayed', 0),
            'matches_won': get_stat_value('matchesWon', 0),
            'matches_lost': get_stat_value('matchesLost', 0),
            'win_rate': get_stat_value('matchesWinPct', 0),
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–∏–ª–ª–æ–≤/—Å–º–µ—Ä—Ç–µ–π
            'kills': get_stat_value('kills', 0),
            'deaths': get_stat_value('deaths', 0),
            'assists': get_stat_value('assists', 0),
            'kd_ratio': get_stat_value('kDRatio', 0),
            'damage_per_round': get_stat_value('damagePerRound', 0),
            'headshot_pct': get_stat_value('headshotPct', 0),
            
            # –†–µ–π—Ç–∏–Ω–≥
            'current_rank': get_rank_info('rank'),
            'current_rr': get_stat_value('rr', 0),
            'peak_rank': None,
            'peak_rr': None,
            
            # –í—Ä–µ–º—è –∏–≥—Ä—ã  
            'time_played': get_stat_value('timePlayed'),
            'matches_duration': get_stat_value('matchesDuration'),
            
            # –î–æ—Å—Ç–∏–∂–µ–Ω–∏—è
            'mvps': get_stat_value('mVPs', 0),
            'match_mvps': get_stat_value('matchMvps', 0),
            'team_mvps': get_stat_value('teamMVPs', 0),
            
            # –ê–≥–µ–Ω—Ç
            'favorite_agent': None,
            'favorite_agent_role': None,
            'agent_matches': 0,
        }
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–∏–∫–æ–≤—ã–π —Ä–µ–π—Ç–∏–Ω–≥
        if peak_rating:
            peak_stats = peak_rating.get('stats', {})
            if 'peakRating' in peak_stats:
                peak_info = peak_stats['peakRating']
                result['peak_rank'] = peak_info.get('metadata', {}).get('tierName')
                result['peak_rr'] = peak_info.get('value', 0)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª—é–±–∏–º–æ–º –∞–≥–µ–Ω—Ç–µ
        if favorite_agent:
            agent_stats = favorite_agent.get('stats', {})
            agent_attrs = favorite_agent.get('attributes', {})
            agent_id = agent_attrs.get('key')
            
            try:
                from ..models.agents import get_agent_name, get_agent_role
                agent_name = get_agent_name(agent_id) if agent_id else "Unknown"
                agent_role = get_agent_role(agent_id) if agent_id else "Unknown"
            except ImportError as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {e}")
                agent_name = "Unknown"
                agent_role = "Unknown"
            except Exception as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–º–µ–Ω–∏ –∞–≥–µ–Ω—Ç–∞: {e}")
                agent_name = agent_attrs.get('name', 'Unknown')  # Fallback –Ω–∞ –∏–º—è –∏–∑ –∞—Ç—Ä–∏–±—É—Ç–æ–≤
                agent_role = "Unknown"
            
            matches_played = agent_stats.get('matchesPlayed', {}).get('displayValue', 0) if agent_stats else 0
            
            result['favorite_agent'] = agent_name
            result['favorite_agent_role'] = agent_role
            result['agent_matches'] = matches_played
            
            print(f"üé≠ –õ—é–±–∏–º—ã–π –∞–≥–µ–Ω—Ç: {agent_name} ({matches_played} –º–∞—Ç—á–µ–π)")
        else:
            print("üé≠ –õ—é–±–∏–º—ã–π –∞–≥–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
        
        return result

    async def get_player_profile(self, riot_id: str, tagline: str) -> Optional[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–≥—Ä–æ–∫–∞ —á–µ—Ä–µ–∑ CloudScraper"""
        
        print(f"üå©Ô∏è –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —á–µ—Ä–µ–∑ CloudScraper: {riot_id}#{tagline}")
        
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –æ–±—ã—á–Ω—ã–π httpx
        httpx_result = await self._try_httpx(riot_id, tagline)
        if httpx_result:
            print("‚úÖ –£—Å–ø–µ—Ö —á–µ—Ä–µ–∑ –æ–±—ã—á–Ω—ã–π httpx!")
            return httpx_result
        
        # –ï—Å–ª–∏ httpx –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø—Ä–æ–±—É–µ–º CloudScraper
        print("üîÑ –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ CloudScraper...")
        cloudscraper_result = await self._try_cloudscraper(riot_id, tagline)
        if cloudscraper_result:
            print("‚úÖ –£—Å–ø–µ—Ö —á–µ—Ä–µ–∑ CloudScraper!")
            return cloudscraper_result
        
        print("‚ùå –í—Å–µ –º–µ—Ç–æ–¥—ã –Ω–µ —É–¥–∞–ª–∏—Å—å")
        return None
    
    async def _try_httpx(self, riot_id: str, tagline: str) -> Optional[Dict]:
        """–ü–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ –æ–±—ã—á–Ω—ã–π httpx"""
        try:
            # URL-–∫–æ–¥–∏—Ä—É–µ–º riot_id –∏ tagline –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∫–∏—Ä–∏–ª–ª–∏—Ü—ã
            encoded_riot_id = urllib.parse.quote(riot_id, safe='')
            encoded_tagline = urllib.parse.quote(tagline, safe='')
            url = f"{self.BASE_URL}/profile/riot/{encoded_riot_id}%23{encoded_tagline}"
            print(f"üì° httpx –∑–∞–ø—Ä–æ—Å: {url}")
            
            response = await self.client.get(url)
            print(f"üìä httpx –æ—Ç–≤–µ—Ç: {response.status_code}")
            
            if response.status_code == 200:
                return response.json()
            else:
                print(f"‚ùå httpx –æ—à–∏–±–∫–∞: {response.status_code}")
                return None
                
        except Exception as e:
            print(f"üí• httpx –∏—Å–∫–ª—é—á–µ–Ω–∏–µ: {e}")
            return None
    
    async def _try_cloudscraper(self, riot_id: str, tagline: str) -> Optional[Dict]:
        """–ü–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ CloudScraper –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""
        import threading
        import asyncio
        
        def cloudscraper_sync(riot_id: str, tagline: str) -> Optional[Dict]:
            """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è CloudScraper"""
            try:
                # URL-–∫–æ–¥–∏—Ä—É–µ–º –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∫–∏—Ä–∏–ª–ª–∏—Ü—ã
                encoded_riot_id = urllib.parse.quote(riot_id, safe='')
                encoded_tagline = urllib.parse.quote(tagline, safe='')
                
                # –°–Ω–∞—á–∞–ª–∞ –ø–æ—Å–µ—â–∞–µ–º –≥–ª–∞–≤–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è cookies
                main_url = f"https://tracker.gg/valorant/profile/riot/{encoded_riot_id}%23{encoded_tagline}/overview"
                print(f"üåê CloudScraper: –ø–æ—Å–µ—â–µ–Ω–∏–µ –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã")
                
                main_response = self.cloud_scraper.get(main_url)
                print(f"üìÑ CloudScraper –≥–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞: {main_response.status_code}")
                
                if main_response.status_code != 200:
                    print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –≥–ª–∞–≤–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É: {main_response.status_code}")
                    return None
                
                # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –∫–∞–∫ –Ω–∞—Å—Ç–æ—è—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
                time.sleep(random.uniform(1, 3))
                
                # –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è API –∑–∞–ø—Ä–æ—Å–∞
                self.cloud_scraper.headers.update({
                    "Referer": main_url,
                    "X-Requested-With": "XMLHttpRequest",
                    "Accept": "application/json, text/plain, */*",
                    "Accept-Encoding": "gzip, deflate, br"  # –í–∞–∂–Ω–æ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –¥–µ–∫–æ–º–ø—Ä–µ—Å—Å–∏–∏
                })
                
                # –¢–µ–ø–µ—Ä—å API –∑–∞–ø—Ä–æ—Å
                api_url = f"{self.BASE_URL}/profile/riot/{encoded_riot_id}%23{encoded_tagline}"
                print(f"üîó CloudScraper API: {api_url}")
                
                api_response = self.cloud_scraper.get(api_url)
                print(f"üì° CloudScraper API –æ—Ç–≤–µ—Ç: {api_response.status_code}")
                print(f"üìã Content-Type: {api_response.headers.get('content-type', 'unknown')}")
                print(f"üîß Content-Encoding: {api_response.headers.get('content-encoding', 'none')}")
                print(f"üì¶ Content-Length: {api_response.headers.get('content-length', 'unknown')}")
                
                if api_response.status_code == 200:
                    try:
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ JSON
                        content_type = api_response.headers.get('content-type', '').lower()
                        
                        if 'application/json' in content_type:
                            print("‚úÖ –ö–æ–Ω—Ç–µ–Ω—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –∫–∞–∫ JSON")
                            
                            # –ü—Ä–æ–±—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–æ—Å–æ–±–æ–≤ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è
                            try:
                                # –°–ø–æ—Å–æ–± 1: –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π .json()
                                data = api_response.json()
                                print("‚úÖ CloudScraper JSON –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω (–º–µ—Ç–æ–¥ 1)")
                                return data
                            except:
                                print("‚ùå –ú–µ—Ç–æ–¥ 1 –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º –º–µ—Ç–æ–¥ 2")
                                
                                try:
                                    # –°–ø–æ—Å–æ–± 2: –†—É—á–Ω–æ–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
                                    import json
                                    text_content = api_response.text
                                    print(f"üìÑ –î–ª–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞: {len(text_content)} —Å–∏–º–≤–æ–ª–æ–≤")
                                    print(f"üìÑ –ü–µ—Ä–≤—ã–µ 100 —Å–∏–º–≤–æ–ª–æ–≤: {repr(text_content[:100])}")
                                    
                                    if text_content.strip():
                                        data = json.loads(text_content)
                                        print("‚úÖ CloudScraper JSON –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω (–º–µ—Ç–æ–¥ 2)")
                                        return data
                                    else:
                                        print("‚ùå –ü—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç")
                                        
                                except Exception as e2:
                                    print(f"‚ùå –ú–µ—Ç–æ–¥ 2 –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e2}")
                                    
                                    try:
                                        # –°–ø–æ—Å–æ–± 3: –†–∞–±–æ—Ç–∞ —Å —Å—ã—Ä—ã–º–∏ –±–∞–π—Ç–∞–º–∏
                                        raw_content = api_response.content
                                        print(f"üì¶ –°—ã—Ä–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç: {len(raw_content)} –±–∞–π—Ç")
                                        print(f"üì¶ –ü–µ—Ä–≤—ã–µ 50 –±–∞–π—Ç: {raw_content[:50]}")
                                        
                                        # –ü—Ä–æ–±—É–µ–º –¥–µ–∫–æ–º–ø—Ä–µ—Å—Å–∏—é
                                        import gzip
                                        import brotli
                                        
                                        encoding = api_response.headers.get('content-encoding', '').lower()
                                        
                                        if encoding == 'gzip':
                                            print("üîß –ü—Ä–æ–±—É–µ–º gzip –¥–µ–∫–æ–º–ø—Ä–µ—Å—Å–∏—é")
                                            decompressed = gzip.decompress(raw_content)
                                            data = json.loads(decompressed.decode('utf-8'))
                                            print("‚úÖ CloudScraper JSON –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω (gzip)")
                                            return data
                                        elif encoding == 'br':
                                            print("üîß –ü—Ä–æ–±—É–µ–º brotli –¥–µ–∫–æ–º–ø—Ä–µ—Å—Å–∏—é")
                                            decompressed = brotli.decompress(raw_content)
                                            data = json.loads(decompressed.decode('utf-8'))
                                            print("‚úÖ CloudScraper JSON –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω (brotli)")
                                            return data
                                        else:
                                            print("üîß –ü—Ä–æ–±—É–µ–º –±–µ–∑ –¥–µ–∫–æ–º–ø—Ä–µ—Å—Å–∏–∏")
                                            data = json.loads(raw_content.decode('utf-8'))
                                            print("‚úÖ CloudScraper JSON –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω (raw)")
                                            return data
                                            
                                    except Exception as e3:
                                        print(f"‚ùå –ú–µ—Ç–æ–¥ 3 –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e3}")
                                        print(f"üìÑ –ü–µ—Ä–≤—ã–µ 200 –±–∞–π—Ç –∫–∞–∫ —Ç–µ–∫—Å—Ç: {repr(raw_content[:200])}")
                        else:
                            print(f"‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π content-type: {content_type}")
                            print(f"üìÑ –ü–µ—Ä–≤—ã–µ 200 —Å–∏–º–≤–æ–ª–æ–≤: {api_response.text[:200]}")
                            
                        return None
                        
                    except Exception as e:
                        print(f"‚ùå –û–±—â–∞—è –æ—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")
                        return None
                else:
                    print(f"‚ùå CloudScraper API –æ—à–∏–±–∫–∞: {api_response.status_code}")
                    
                    # –í—ã–≤–æ–¥–∏–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
                    print("üìã –ó–∞–≥–æ–ª–æ–≤–∫–∏ –æ—Ç–≤–µ—Ç–∞:")
                    for key, value in api_response.headers.items():
                        if key.lower() in ['cf-ray', 'server', 'cf-cache-status', 'content-type', 'content-encoding']:
                            print(f"   {key}: {value}")
                    
                    print(f"üìÑ –û—Ç–≤–µ—Ç: {api_response.text[:300]}")
                    return None
                    
            except Exception as e:
                print(f"üí• CloudScraper –∏—Å–∫–ª—é—á–µ–Ω–∏–µ: {e}")
                import traceback
                traceback.print_exc()
                return None
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º CloudScraper –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, cloudscraper_sync, riot_id, tagline)
    
    def extract_current_season_stats(self, profile_data: Dict, current_rank: str = None) -> Dict:
        """–ò–∑–≤–ª–µ—á—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–µ–∫—É—â–µ–≥–æ —Å–µ–∑–æ–Ω–∞"""
        if not profile_data or 'data' not in profile_data:
            return {}
            
        segments = profile_data['data'].get('segments', [])
        current_season = None
        rank_segment = None
        
        print(f"üîç extract_current_season_stats: –Ω–∞–π–¥–µ–Ω–æ {len(segments)} —Å–µ–≥–º–µ–Ω—Ç–æ–≤")
        
        # –ù–∞–π—Ç–∏ —Å–µ–≥–º–µ–Ω—Ç —Ç–µ–∫—É—â–µ–≥–æ —Å–µ–∑–æ–Ω–∞ –∏ —Å–µ–≥–º–µ–Ω—Ç —Å —Ä–∞–Ω–≥–æ–º
        for i, segment in enumerate(segments):
            segment_type = segment.get('type')
            metadata = segment.get('metadata', {})
            
            print(f"üîç –°–µ–≥–º–µ–Ω—Ç {i}: type={segment_type}, metadata_keys={list(metadata.keys())}")
            
            if segment_type == 'season' and segment.get('attributes', {}).get('playlist') == 'competitive':
                current_season = segment
                print(f"üîç –ù–∞–π–¥–µ–Ω current_season (season)")
            
            # –ò—â–µ–º –õ–Æ–ë–û–ô —Å–µ–≥–º–µ–Ω—Ç —Å —Ä–∞–Ω–≥–æ–º (–Ω–µ —Ç–æ–ª—å–∫–æ season)
            if 'tierName' in metadata and not rank_segment:
                rank_segment = segment
                print(f"üîç –ù–∞–π–¥–µ–Ω rank_segment —Ç–∏–ø–∞ {segment_type} —Å tierName: {metadata.get('tierName')}")
                
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ season —Å–µ–≥–º–µ–Ω—Ç, –ø–æ–ø—Ä–æ–±—É–µ–º overview
        if not current_season:
            for segment in segments:
                if segment.get('type') == 'overview':
                    current_season = segment
                    print(f"üîç –ò—Å–ø–æ–ª—å–∑—É–µ–º overview —Å–µ–≥–º–µ–Ω—Ç –∫–∞–∫ current_season")
                    break
        
        if not current_season:
            print("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω —Å–µ–≥–º–µ–Ω—Ç —Ç–µ–∫—É—â–µ–≥–æ —Å–µ–∑–æ–Ω–∞ –¥–ª—è extract_current_season_stats")
            return {}
            
        stats = current_season.get('stats', {})
        metadata = current_season.get('metadata', {})
        
        print(f"üîç extract_current_season_stats metadata: {metadata}")
        
        # –ü–æ–ª—É—á–∞–µ–º —Ä–∞–Ω–≥ –∏–∑ —Ä–∞–∑–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
        rank = None
        
        # –ï—Å–ª–∏ —Ä–∞–Ω–≥ –ø–µ—Ä–µ–¥–∞–Ω –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä (–∏–∑ get_enhanced_player_stats), –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
        if current_rank:
            rank = current_rank
            print(f"üîç –†–∞–Ω–≥ –ø–æ–ª—É—á–µ–Ω –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä: {rank}")
        
        # –ï—Å–ª–∏ –µ—Å—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–π —Å–µ–≥–º–µ–Ω—Ç —Å —Ä–∞–Ω–≥–æ–º, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
        elif rank_segment:
            rank_metadata = rank_segment.get('metadata', {})
            if 'tierName' in rank_metadata:
                rank = rank_metadata['tierName']
                print(f"üîç –†–∞–Ω–≥ –∏–∑ rank_segment.metadata.tierName: {rank}")
        
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Å–µ–≥–º–µ–Ω—Ç–µ, –ø—Ä–æ–±—É–µ–º —Ç–µ–∫—É—â–∏–π —Å–µ–≥–º–µ–Ω—Ç
        elif not rank:
            # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º metadata.tierName
            if 'tierName' in metadata:
                rank = metadata['tierName']
                print(f"üîç –†–∞–Ω–≥ –∏–∑ current_season.metadata.tierName: {rank}")
            # –ü–æ—Ç–æ–º –ø—Ä–æ–±—É–µ–º stats.rank
            elif 'rank' in stats:
                rank_stat = stats['rank']
                if isinstance(rank_stat, dict):
                    rank = rank_stat.get('displayValue') or rank_stat.get('value')
                else:
                    rank = str(rank_stat)
                print(f"üîç –†–∞–Ω–≥ –∏–∑ stats.rank: {rank}")
        
        if not rank or rank == "Unranked":
            rank = "–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω"
            
        print(f"üîç –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–∞–Ω–≥ –≤ extract_current_season_stats: {rank}")
            
        result = {
            'season_name': metadata.get('name', ''),
            'matches_played': self._get_stat_value(stats, 'matchesPlayed'),
            'matches_won': self._get_stat_value(stats, 'matchesWon'),
            'win_rate': self._get_stat_value(stats, 'matchesWinPct'),
            'kd_ratio': self._get_stat_value(stats, 'kDRatio'),
            'average_score': self._get_stat_value(stats, 'scorePerMatch'),
            'headshot_percentage': self._get_stat_value(stats, 'headshotsPercentage'),
            'clutches_won': self._get_stat_value(stats, 'clutches'),
            'clutch_percentage': self._get_stat_value(stats, 'clutchesPercentage'),
            'aces': self._get_stat_value(stats, 'aces'),
            'rank': rank,  # –î–æ–±–∞–≤–ª—è–µ–º —Ä–∞–Ω–≥
            'attack_kd': self._get_stat_value(stats, 'attackKDRatio'),
            'defense_kd': self._get_stat_value(stats, 'defenseKDRatio'),
            'econ_rating': self._get_stat_value(stats, 'econRating')
        }
        
        print(f"üîç extract_current_season_stats —Ä–µ–∑—É–ª—å—Ç–∞—Ç: rank={result['rank']}")
        return result
    
    def extract_agent_stats(self, profile_data: Dict) -> List[Dict]:
        """–ò–∑–≤–ª–µ—á—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∞–≥–µ–Ω—Ç–∞–º"""
        if not profile_data or 'data' not in profile_data:
            return []
            
        segments = profile_data['data'].get('segments', [])
        agents = []
        
        for segment in segments:
            if segment.get('type') == 'agent':
                metadata = segment.get('metadata', {})
                stats = segment.get('stats', {})
                
                agent_data = {
                    'name': metadata.get('name', ''),
                    'role': metadata.get('role', ''),
                    'color': metadata.get('color', ''),
                    'image_url': metadata.get('imageUrl', ''),
                    'matches_played': self._get_stat_value(stats, 'matchesPlayed'),
                    'win_rate': self._get_stat_value(stats, 'matchesWinPct'),
                    'kd_ratio': self._get_stat_value(stats, 'kDRatio'),
                    'average_score': self._get_stat_value(stats, 'scorePerMatch'),
                    'headshot_percentage': self._get_stat_value(stats, 'headshotsPercentage'),
                    'ability1_kills': self._get_stat_value(stats, 'ability1Kills'),
                    'ability2_kills': self._get_stat_value(stats, 'ability2Kills'),
                    'ultimate_kills': self._get_stat_value(stats, 'ultimateKills')
                }
                agents.append(agent_data)
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∏–≥—Ä
        return sorted(agents, key=lambda x: x['matches_played'] or 0, reverse=True)
    
    def extract_clutch_stats(self, profile_data: Dict) -> Dict:
        """–ò–∑–≤–ª–µ—á—å –¥–µ—Ç–∞–ª—å–Ω—É—é –∫–ª–∞—Ç—á —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        if not profile_data or 'data' not in profile_data:
            return {}
            
        segments = profile_data['data'].get('segments', [])
        season_segment = None
        
        for segment in segments:
            if segment.get('type') == 'season':
                season_segment = segment
                break
                
        if not season_segment:
            return {}
            
        stats = season_segment.get('stats', {})
        
        return {
            'total_clutches': self._get_stat_value(stats, 'clutches'),
            'clutch_percentage': self._get_stat_value(stats, 'clutchesPercentage'),
            'clutches_1v1': self._get_stat_value(stats, 'clutches1v1'),
            'clutches_1v2': self._get_stat_value(stats, 'clutches1v2'),
            'clutches_1v3': self._get_stat_value(stats, 'clutches1v3'),
            'clutches_1v4': self._get_stat_value(stats, 'clutches1v4'),
            'clutches_1v5': self._get_stat_value(stats, 'clutches1v5'),
            'clutches_lost': self._get_stat_value(stats, 'clutchesLost'),
            'clutches_lost_1v1': self._get_stat_value(stats, 'clutchesLost1v1'),
            'clutches_lost_1v2': self._get_stat_value(stats, 'clutchesLost1v2'),
            'clutches_lost_1v3': self._get_stat_value(stats, 'clutchesLost1v3'),
            'clutches_lost_1v4': self._get_stat_value(stats, 'clutchesLost4'),
            'clutches_lost_1v5': self._get_stat_value(stats, 'clutchesLost1v5')
        }
    
    def get_player_summary(self, profile_data: Dict) -> Dict:
        """–°–æ–∑–¥–∞—Ç—å –∫—Ä–∞—Ç–∫—É—é —Å–≤–æ–¥–∫—É –∏–≥—Ä–æ–∫–∞"""
        if not profile_data or 'data' not in profile_data:
            return {}
            
        data = profile_data['data']
        platform_info = data.get('platformInfo', {})
        user_info = data.get('userInfo', {})
        metadata = data.get('metadata', {})
        
        # –ü–æ–ª—É—á–∏—Ç—å —Ä–∞–Ω–≥ –∏–∑ —Ç–æ–≥–æ –∂–µ –º–µ—Å—Ç–∞ —á—Ç–æ –∏ –≤ get_enhanced_player_stats
        current_rank = None
        segments = data.get('segments', [])
        
        for segment in segments:
            if segment.get('type') == 'season' and segment.get('attributes', {}).get('playlist') == 'competitive':
                stats = segment.get('stats', {})
                if 'rank' in stats:
                    rank_info = stats['rank']
                    metadata = rank_info.get('metadata', {})
                    tier_name = metadata.get('tierName')
                    if tier_name:
                        current_rank = tier_name
                        break
        
        # –ü–æ–ª—É—á–∏—Ç—å –æ—Å–Ω–æ–≤–Ω—ã–µ —Å—Ç–∞—Ç—ã
        current_stats = self.extract_current_season_stats(profile_data, current_rank)
        top_agents = self.extract_agent_stats(profile_data)[:3]  # –¢–æ–ø 3 –∞–≥–µ–Ω—Ç–∞
        clutch_stats = self.extract_clutch_stats(profile_data)
        
        return {
            'riot_id': platform_info.get('platformUserHandle', ''),
            'avatar_url': platform_info.get('avatarUrl', ''),
            'account_level': metadata.get('accountLevel', 0),
            'region': metadata.get('activeShard', ''),
            'profile_views': user_info.get('pageviews', 0),
            'badges_count': len(user_info.get('badges', [])),
            'current_season': current_stats,
            'top_agents': top_agents,
            'clutch_master': clutch_stats,
            'is_clutch_god': (clutch_stats.get('clutch_percentage', 0) or 0) > 50,
            'main_role': self._determine_main_role(top_agents),
            'play_style': self._analyze_play_style(current_stats, clutch_stats)
        }
    
    def _get_stat_value(self, stats: Dict, key: str, is_string: bool = False) -> Any:
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        if key not in stats:
            return None if is_string else 0
            
        stat = stats[key]
        if isinstance(stat, dict):
            return stat.get('value')
        return stat
    
    def _determine_main_role(self, agents: List[Dict]) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –æ—Å–Ω–æ–≤–Ω—É—é —Ä–æ–ª—å –∏–≥—Ä–æ–∫–∞"""
        if not agents:
            return "Unknown"
            
        role_games = {}
        for agent in agents:
            role = agent.get('role', 'Unknown')
            games = agent.get('matches_played', 0)
            role_games[role] = role_games.get(role, 0) + games
            
        return max(role_games, key=role_games.get) if role_games else "Unknown"
    
    def _analyze_play_style(self, season_stats: Dict, clutch_stats: Dict) -> str:
        """–ê–Ω–∞–ª–∏–∑ —Å—Ç–∏–ª—è –∏–≥—Ä—ã"""
        if not season_stats:
            return "Unknown"
            
        kd = season_stats.get('kd_ratio', 0) or 0
        clutch_rate = clutch_stats.get('clutch_percentage', 0) or 0
        headshot_pct = season_stats.get('headshot_percentage', 0) or 0
        
        if clutch_rate > 60:
            return "üî• Clutch God"
        elif kd > 1.3 and headshot_pct > 25:
            return "üéØ Precision Killer"  
        elif kd > 1.1:
            return "‚öîÔ∏è Aggressive Fragger"
        elif clutch_rate > 40:
            return "üß† Clutch Player"
        elif headshot_pct > 30:
            return "üî´ Aim Master"
        else:
            return "üéÆ Balanced Player"
    
    async def close(self):
        """–ó–∞–∫—Ä—ã—Ç—å –≤—Å–µ –∫–ª–∏–µ–Ω—Ç—ã"""
        await self.client.aclose()

# –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å CloudScraper
async def test_cloudscraper():
    """–¢–µ—Å—Ç CloudScraper –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏"""
    api = TrackerGGAPI()
    
    try:
        print("üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ TrackerGG —Å CloudScraper...")
        profile = await api.get_player_profile("porsche enjoyer", "ild")
        
        if profile:
            print("‚úÖ –ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—É—á–µ–Ω —É—Å–ø–µ—à–Ω–æ!")
            summary = api.get_player_summary(profile)
            print(f"üìä –ò–≥—Ä–æ–∫: {summary.get('riot_id', 'Unknown')}")
            print(f"üéÆ –£—Ä–æ–≤–µ–Ω—å: {summary.get('account_level', 0)}")
            print(f"üèÜ –°—Ç–∏–ª—å: {summary.get('play_style', 'Unknown')}")
            
            # –ü–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            current_season = summary.get('current_season', {})
            if current_season:
                print(f"\nüìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ–∑–æ–Ω–∞:")
                print(f"   üéØ –ú–∞—Ç—á–µ–π: {current_season.get('matches_played', 0)}")
                print(f"   üèÜ –í–∏–Ω—Ä–µ–π—Ç: {current_season.get('win_rate', 0):.1f}%")
                print(f"   ‚öîÔ∏è K/D: {current_season.get('kd_ratio', 0):.2f}")
                print(f"   üéØ HS%: {current_season.get('headshot_percentage', 0):.1f}%")
                
            top_agents = summary.get('top_agents', [])
            if top_agents:
                print(f"\nüë• –¢–æ–ø –∞–≥–µ–Ω—Ç—ã:")
                for i, agent in enumerate(top_agents, 1):
                    print(f"   {i}. {agent.get('name', 'Unknown')} ({agent.get('role', 'Unknown')})")
                    print(f"      üéÆ –ò–≥—Ä: {agent.get('matches_played', 0)} | üèÜ WR: {agent.get('win_rate', 0):.1f}% | ‚öîÔ∏è K/D: {agent.get('kd_ratio', 0):.2f}")
        else:
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å")
            
    finally:
        await api.close()

if __name__ == "__main__":
    asyncio.run(test_cloudscraper())